## 26. 尽可能延后变量定义式的出现时间
尽量延后定义至使用，至有值可以初始化；当在循环代码块的情况下，需要具体比较在循环内、在循环外定义变量的代价

## 27. 尽量少做转型动作
standard conversion
当从范围小的数据类型转换为范围大的数据类型时，称为promotion，可以保证数据没有精度损失，例如from float to double，

type cast  
- functiontional cast  
const_cast<T>(expression):常量性移除  
dynamic_cast<T>(expression)：安全向下转型，用来决定某对象是否归属继承体系中的某个类型  
reinterpret_cast<T>(expression)：低级转型，实际动作取决于编译器，具有不可移植性，　能够在unrelated class的类型指针之间转换      
static_cast<T>(expression)：强迫隐式转换，能够转换related class的类型指针  
- c-like cast
(new_type) expression
new_type(expression)

要倾向于使用新式转型，因为更容易辨识
core dump(核心倾印)

## 28. 避免返回handles指向对象内部成分
references、指针、迭代器都是handles(号码牌，用来取得某个对象)

## 29.为异常安全而努力是值得的
“四十年前，满载goto的代码被视为一种美好实践，而今我们却致力写出结构化控制流。二十年前，全局数据被视为一种美好实践，而今我们致力于数据的封装。十年前，撰写未将异常考虑在内的函数被视为一种美好实践，而今我们致力于写出异常安全码”

以对象(智能指针、设计类)管理资源(资源包括内存、互斥锁)的思想

异常安全性要做到：
- 不泄漏任何资源
- 不允许数据败坏

带异常安全性的函数会提供三个保证之一：
- 基本承诺：如果异常被抛出，程序内的任何事物仍然保持在有效状态下。没有任何对象或者数据结构会因此被破坏。比如上例中本次更换背景图失败，不会导致相关的数据发生破坏。
- 强烈保证：在基本承诺的基础上，保证成功就是完全成功，失败也能回到之前的状态，不存在介于成功或失败之间的状态。
- 不抛出异常：承诺这个代码在任何情况下都不会抛出异常，但这只适用于简单的语句。


## 30. 透彻理解inline函数
类内函数都被隐喻声明为inline函数，包括在类内用friend指明的友元函数，其次，inline指明的内联函数，这些函数会被编译器尝试链接成内联的，但也不一定能够具现化
在调试版程序中禁止inlining

## 31. 将文件间的编译依存关系降至最低
类的声明式
类的定义式
相依于声明式，不要相依于定义式